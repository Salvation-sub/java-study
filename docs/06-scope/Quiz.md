# Java 변수와 스코프

## 1. 지역 변수의 사용 범위

지역 변수는 **선언된 코드 블록 안에서만** 사용할 수 있습니다.

### 핵심 개념
- 지역 변수는 선언된 코드 블록 내에서만 유효합니다
- 해당 블록을 벗어나면 변수가 메모리에서 사라져 접근할 수 없습니다
- 프로그램 전체나 다른 메서드에서는 사용할 수 없습니다

```java
public void example() {
    {
        int localVar = 10; // 이 블록 내에서만 유효
        System.out.println(localVar); // 정상 출력
    }
    // System.out.println(localVar); // 오류! 변수에 접근 불가
}
```

## 2. 변수 스코프를 좁게 제한하는 이유

변수의 스코프를 좁게 제한하면 **메모리를 효율적으로 사용하고 코드 이해가 쉬워집니다**.

### 장점
- **메모리 효율성**: 필요할 때만 메모리를 사용합니다
- **코드 가독성**: 불필요한 변수를 고려할 필요가 없어 복잡성이 줄어듭니다
- **유지보수성**: 변수의 영향 범위가 명확해져 버그 발생 가능성이 줄어듭니다
- **변수 충돌 방지**: 같은 이름의 변수로 인한 혼동을 방지합니다

## 3. 명시적 형변환(Explicit Casting)

큰 범위 타입의 값을 작은 범위 타입으로 변환할 때는 명시적 형변환이 필요합니다.

### 이유
**데이터 손실(값의 잘림 또는 오버플로우)이 발생할 수 있기 때문**입니다.

### 예시
```java
double largeValue = 123.456;
int smallValue = (int) largeValue; // 명시적 형변환 필요 (소수점 손실)

long bigNumber = 3000000000L;
int normalNumber = (int) bigNumber; // 명시적 형변환 필요 (오버플로우 가능)
```

## 4. 자동 형변환(Implicit Casting)

`int` 타입의 값을 `double` 타입으로 자동 형변환하는 것이 가능한 이유는 **`double`이 `int`보다 표현 범위가 넓기 때문**입니다.

### 특징
- 데이터 손실이 없는 안전한 변환입니다
- 컴파일러가 자동으로 처리합니다
- 작은 범위에서 큰 범위로의 변환은 항상 안전합니다

```java
int intValue = 42;
double doubleValue = intValue; // 자동 형변환 (안전함)
```

## 5. 서로 다른 숫자 타입 간의 계산

`int`와 `double` 같이 서로 다른 숫자 타입 간의 계산은 **두 타입 중 큰 범위 타입으로 자동 형변환되어 계산됩니다**.

### 타입 확장 규칙
1. 계산 전에 더 넓은 범위의 타입으로 자동 변환
2. 데이터 손실을 방지하기 위한 Java의 안전장치
3. 결과도 큰 범위 타입으로 반환됩니다

```java
int intNum = 10;
double doubleNum = 3.14;
double result = intNum + doubleNum; // int가 double로 변환되어 계산
// 결과: 13.14 (double 타입)
```

### 타입 확장 순서
`byte` → `short` → `int` → `long` → `float` → `double`

## 정리

- 지역 변수는 선언된 블록 내에서만 사용 가능
- 스코프를 좁게 제한하면 메모리 효율성과 코드 가독성이 향상
- 큰 타입에서 작은 타입으로의 변환은 명시적 형변환 필요 (데이터 손실 위험)
- 작은 타입에서 큰 타입으로의 변환은 자동 형변환 가능 (안전함)
- 서로 다른 숫자 타입 간 계산은 큰 범위 타입으로 자동 변환되어 처리